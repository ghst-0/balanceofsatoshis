#!/usr/bin/env node
const {lstat} = require('fs');
const {mkdir} = require('fs');
const {readdir} = require('fs');
const {readFile} = require('fs');
const {rmdir} = require('fs');
const {spawn} = require('child_process');
const {statSync} = require('fs');
const {unlink} = require('fs');
const {writeFile} = require('fs');

const importLazy = require('import-lazy')(require);

const fetch = importLazy('@alexbosworth/node-fetch');
const lnService = importLazy('ln-service');
const lnSync = importLazy('ln-sync');
const prog = require('@alexbosworth/caporal');

const commandConstants = require('./commands/constants');

const {accountingCategories} = commandConstants;
const balances = importLazy('./balances');
const chain = importLazy('./chain');
const commands = importLazy('./commands');
const display = importLazy('./display');
const encryption = importLazy('./encryption');
const lnd = importLazy('./lnd');
const network = importLazy('./network');
const nodes = importLazy('./nodes');
const {peerSortOptions} = commandConstants;
const {rateProviders} = commandConstants;
const responses = importLazy('./responses');
const routing = importLazy('./routing');
const rocketchat = importLazy('./rocketchat');
const triggers = importLazy('./triggers');
const wallets = importLazy('./wallets');
const {version} = importLazy('./package');

const {BOOL} = prog;
const collect = arr => [].concat(...[arr]).filter(n => !!n);
const {exit} = process;
const flatten = arr => [].concat(...arr);
const {INT} = prog;
const {keys} = Object;
const lndForNode = (logger, node) => lnd.authenticatedLnd({logger, node});
const months = [...Array(12).keys()].map(n => ++n);
const {REPEATABLE} = prog;
const {STRING} = prog;
const yearMatch = /^\d{4}$/;

prog
  .version(version)

  // Get accounting information
  .command('accounting', 'Get an accounting rundown')
  .argument('<category>', 'Report category', keys(accountingCategories))
  .help(`Categories: ${keys(accountingCategories).join(', ')}`)
  .help(`Rate providers: ${rateProviders.join(', ')}`)
  .help('Privacy note: this requests tx related data from third parties')
  .option('--csv', 'Output a CSV')
  .option('--date <day>', 'Show only records for specific date')
  .option('--disable-fiat', 'Avoid looking up fiat conversions for records')
  .option('--month <month>', 'Show only records for specific month', months)
  .option('--node <node_name>', 'Get details from named node')
  .option('--rate-provider <rate_provider>', 'Rate provider', rateProviders)
  .option('--year <year>', 'Show only records for specified year', yearMatch)
  .action((args, options, logger) => {
    const table = !!options.csv ? null : 'rows';

    return new Promise(async (resolve, reject) => {
      try {
        return balances.getAccountingReport({
          category: args.category,
          date: options.date,
          is_csv: !!options.csv,
          is_fiat_disabled: options.disableFiat,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          month: options.month,
          node: options.node,
          rate_provider: options.rateProvider,
          request: commands.simpleRequest,
          year: options.year,
        },
        responses.returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get local balance information
  .command('balance', 'Get total tokens')
  .help('Sums balances on-chain, in channels, and pending, plus commit fees')
  .help('Multiple --node arguments are supported to sum across nodes')
  .option('--above <tokens>', 'Return tokens above watermark', INT)
  .option('--below <tokens>', 'Return tokens below watermark', INT)
  .option('--confirmed', 'Return confirmed funds only')
  .option('--detailed', 'Return detailed balance information')
  .option('--node <node_name>', 'Node to get balance for', REPEATABLE)
  .option('--offchain', 'List only off-chain tokens')
  .option('--onchain', 'List only on-chain tokens')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        // Exit early when detailed balance details are requested
        if (!!options.detailed) {
          return balances.getDetailedBalance({
            lnds: (await lnd.getLnds({logger, nodes: options.node})).lnds,
            is_confirmed: options.confirmed,
          },
          responses.returnObject({logger, reject, resolve}));
        }

        return balances.getBalance({
          above: options.above,
          below: options.below,
          is_confirmed: !!options.confirmed,
          is_offchain_only: !!options.offchain,
          is_onchain_only: !!options.onchain,
          lnd: (await lndForNode(logger, options.node)).lnd,
        },
        responses.returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get the number of days until the RPC cert expires
  .command('cert-validity-days', 'Number of days until the cert is invalid')
  .option('--below <number_of_days>', 'Return number of days below mark', INT)
  .option('--node <node_name>', 'Node to check cert on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      return lnd.getCertValidityDays({
        logger,
        below: options.below,
        node: options.node,
      },
      responses.returnNumber({logger, reject, resolve, number: 'days'}));
    });
  })

  // Get the current chain fee rates
  .command('chainfees', 'Get the current chain fee estimates')
  .help('Lookup chain fee estimates at various confirm targets')
  .option('--blocks <depth>', 'Blocks confirm target depth to estimate to')
  .option('--file <path>', 'Write the output to a JSON file at desired path')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get chain fees view from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return chain.getChainFees({
          blocks: options.blocks,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
        },
        responses.returnObject({
          logger,
          reject,
          resolve,
          file: options.file,
          write: writeFile,
        }));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Show a chart of chain fees paid
  .command('chart-chain-fees', 'Get a chart of chain fee expenses')
  .help('Show chart of mining fee expenditure over time')
  .help('Privacy note: this requests tx data from third parties')
  .option('--days <days>', 'Chart over the past number of days', INT)
  .option('--end <end_date>', 'End date for chart as YYYY-MM-DD', STRING)
  .option('--no-color', 'Disable colors')
  .option('--node <node_name>', 'Chain fees from saved node(s)', REPEATABLE)
  .option('--start <start_date>', 'Start date for chart as YYYY-MM-DD', STRING)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return routing.getChainFeesChart({
          days: options.days,
          end_date: options.end,
          is_monochrome: !!options.noColor,
          lnds: (await lnd.getLnds({logger, nodes: options.node})).lnds,
          request: commands.simpleRequest,
          start_date: options.start,
        },
        responses.returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Show a chart of fees earned
  .command('chart-fees-earned', 'Get a chart of earned routing fees')
  .argument('[via]', 'Routing fees earned via a specified node or tag')
  .help('Show the routing fees earned')
  .option('--count', 'Show count of forwards instead of fees earned')
  .option('--days <days>', 'Chart fees over the past number of days', INT)
  .option('--end <end_date>', 'End date for chart as YYYY-MM-DD', STRING)
  .option('--forwarded', 'Show amount forwarded instead of fees earned')
  .option('--node <node_name>', 'Get saved node fees earned', REPEATABLE)
  .option('--start <start_date>', 'Start date for chart as YYYY-MM-DD', STRING)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return routing.getFeesChart({
          days: options.days,
          end_date: options.end,
          fs: {getFile: readFile},
          is_count: options.count,
          is_forwarded: options.forwarded,
          lnds: (await lnd.getLnds({logger, nodes: options.node})).lnds,
          start_date: options.start,
          via: args.via || undefined,
        },
        responses.returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Show a chart of routing fees paid
  .command('chart-fees-paid', 'Get a chart of paid routing fees')
  .help('Show the routing fees paid to forwarding nodes')
  .help('--rebalances can return results much more quickly')
  .option('--days <days>', 'Chart fees over the past number of days', INT)
  .option('--end <end_date>', 'End date for chart as YYYY-MM-DD', STRING)
  .option('--in <key_or_alias>', 'Fees paid on routes in node with peer')
  .option('--most-fees', 'View table of fees paid per node')
  .option('--most-forwarded', 'View table of forwarded per node')
  .option('--network', 'Show only non-peers in table view')
  .option('--node <node_name>', 'Get fees chart for saved node(s)', REPEATABLE)
  .option('--out <key_or_alias>', 'Fees paid on routes out node with peer')
  .option('--peers', 'Show only peers in table view')
  .option('--rebalances', 'Only consider fees paid in self-to-self transfers')
  .option('--start <start_date>', 'Start date for chart as YYYY-MM-DD', STRING)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const data = 'data';
      const table = 'rows';

      const asTable = responses.returnObject({logger, reject, resolve, table});
      const chart = responses.returnChart({data, logger, reject, resolve});

      try {
        return routing.getFeesPaid({
          days: options.days,
          end_date: options.end,
          fs: {getFile: readFile},
          in: options.in,
          is_most_fees_table: options.mostFees,
          is_most_forwarded_table: options.mostForwarded,
          is_network: options.network,
          is_peer: options.peers,
          is_rebalances_only: options.rebalances,
          lnds: (await lnd.getLnds({logger, nodes: options.node})).lnds,
          out: options.out,
          start_date: options.start,
        },
        (options.mostFees || options.mostForwarded) ? asTable : chart);
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Chart earnings from payments received
  .command('chart-payments-received', 'Get a chart of received payments')
  .help('Show chart for settled invoices from external parties')
  .option('--count', 'Show count of settled instead of amount received')
  .option('--days <days>', 'Chart over the past number of days', INT)
  .option('--end <end_date>', 'Final date for chart as YYYY-MM-DD', STRING)
  .option('--for <query>', 'Only consider payments including a specific query')
  .option('--node <node_name>', 'Get payments from saved node(s)', REPEATABLE)
  .option('--start <start_date>', 'Start date for chart as YYYY-MM-DD', STRING)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return wallets.getReceivedChart({
          days: options.days,
          end_date: options.end,
          is_count: options.count,
          lnds: (await lnd.getLnds({logger, nodes: options.node})).lnds,
          query: options.for,
          start_date: options.start,
        },
        responses.returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Clean a command of unnecessary references
  .command('clean-command', 'Clean command to remove outdated references')
  .visible(false)
  .argument('<command>', 'Escaped command to cleanup')
  .option('--node <node_name>', 'Saved node to use for lookups')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return commands.clean({
          lnd: (await lndForNode(logger, options.node)).lnd,
          command: args.command,
        },
        responses.returnOutput({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Determine the outcomes of channel closings
  .command('closed', 'Get the status of a channel closings')
  .help('Channel closes with chain-transaction derived resolution details')
  .help('Privacy note: this requests tx data from third parties')
  .option('--limit [limit]', 'Limit of closings to get', INT, 20)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Get channel closes from saved node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return chain.getChannelCloses({
          limit: options.limit,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          request: commands.simpleRequest,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Export LND credentials
  .command('credentials', 'Export local credentials')
  .help('Output encrypted remote access credentials. Use with "nodes --add"')
  .option('--cleartext', 'Output remote access credentials without encryption')
  .option('--days <days>', 'Expiration days for credentials', INT, 365)
  .option('--method <method_name>', 'White-list specific method', REPEATABLE)
  .option('--node <node_name>', 'Get credentials for a saved node')
  .option('--nospend', 'Credentials do not include spending privileges')
  .option('--readonly', 'Credentials only include read permissions')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      return lnd.getCredentials({
        logger,
        ask: await commands.interrogate({}),
        expire_days: options.days,
        is_cleartext: options.cleartext,
        is_nospend: options.nospend,
        is_readonly: options.readonly,
        methods: flatten([options.method].filter(n => !!n)),
        node: options.node,
      },
      responses.returnObject({logger, reject, resolve}));
    });
  })

  // Decrypt a message
  .command('decrypt', 'Decrypt data using the node key')
  .visible(false)
  .argument('<encrypted>', 'Encrypted message')
  .help('Decrypt a message encrypted to the node key or to another node key')
  .option('--node <node_name>', 'Node to decrypt with')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return encryption.decryptWithNode({
          encrypted: args.encrypted,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Delete all payments
  .command('delete-payments-history', 'Delete all records of past payments')
  .visible(false)
  .option('--node <node_name>', 'Node to delete all past payments on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return lnService.deletePayments({
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Encrypt a message
  .command('encrypt', 'Encrypt data using the node key')
  .visible(false)
  .help('Encrypt a message to the node key or to another node key')
  .option('--node <node_name>', 'Node to encrypt with')
  .option('--message <message>', 'Text message to encrypt')
  .option('--to <to>', 'Encrypt message to another node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return encryption.encryptToNode({
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          message: options.message,
          to: options.to,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Fan out utxos
  .command('fanout', 'Fan out utxos')
  .visible(false)
  .argument('<size>', 'UTXO minimum size', INT)
  .argument('<count>', 'Desired number of total utxos', INT)
  .help('Make a bunch of utxos by making a tx with a bunch of outputs')
  .option('--confirmed', 'Only consider confirmed existing utxos')
  .option('--dryrun', 'Execute a fan-out dry run')
  .option('--feerate <feerate>', 'Feerate in per vbyte rate', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to do fan out for')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return chain.splitUtxos({
          count: args.count,
          is_confirmed: !!options.confirmed,
          is_dry_run: !!options.dryrun,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          size: args.size,
          tokens_per_vbyte: options.feerate,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Show and set routing policy fee rates
  .command('fees', 'Show and adjust routing fee rates')
  .help('List out fee rates, fix problems with routing policies, set out fees')
  .help('When setting fee, if channels pending, will wait for confirm to set')
  .help('--set-fee-rate can use formulas: https://formulajs.info/functions/')
  .help('Specify PERCENT(0.00) to set the fee as a fraction of routed amount')
  .help('Specify BIPS() to set the fee as parts per thousand')
  .help('You can use INBOUND and OUTBOUND in formulas for IF formulas')
  .help('You can use INBOUND_FEE_RATE to mirror an inbound fee')
  .help('You can use FEE_RATE_OF_<PUBKEY> to reference other node rates')
  .help('--set-inbound-discount-rate is total discount on traffic from peer')
  .option('--node <node_name>', 'Saved node (not peer to set fees on)')
  .option('--set-cltv-delta <count>', 'Set the number of blocks for CLTV', INT)
  .option('--set-fee-rate <rate>', 'Fee in parts per million or use a formula')
  .option('--set-inbound-rate-discount <rate>', 'Source discount rate in PPM')
  .option('--to <peer>', 'Peer key/alias/tag to set fees', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return routing.adjustFees({
          logger,
          cltv_delta: options.setCltvDelta,
          fee_rate: options.setFeeRate,
          fs: {getFile: readFile},
          inbound_rate_discount: options.setInboundRateDiscount,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          to: flatten([options.to].filter(n => !!n)),
        },
        responses.returnObject({logger, reject, resolve, table: 'rows'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Query the node to search for something
  .command('find', 'Find a record')
  .help('Look for something in the node db that matches a query')
  .argument('<query>', 'Query for a record')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to find record on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return lnd.findRecord({
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          query: args.query,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get forwards
  .command('forwards', 'Show recent forwarding earnings')
  .help('Peers where routing has taken place from inbound and outbound sides')
  .help('Sorts: earned_in/earned_out/earned_total/inbound/liquidity/outbound')
  .option('--complete', 'Show complete set of records in non table view')
  .option('--days <days>', 'Number of past days to evaluate', INT)
  .option('--in <from>', 'Forwards that originated from a specific peer')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get forwards for')
  .option('--out <to>', 'Forwards that sent out to a specified peer')
  .option('--sort <type>', 'Sort forward-active peers by earnings/liquidity')
  .option('--tag <tag_name>', 'Only show peers in a tag', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await lndForNode(logger, options.node);
        const table = !!options.complete ? undefined : 'rows';

        return network.getForwards({
          lnd,
          days: options.days,
          from: (await lnSync.findKey({lnd, query: options.in})).public_key,
          fs: {getFile: readFile},
          is_monochrome: !!options.noColor,
          is_table: !options.complete,
          sort: options.sort || undefined,
          tags: collect(options.tag),
          to: (await lnSync.findKey({lnd, query: options.out})).public_key,
        },
        responses.returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get the edges of a given node
  .command('graph', 'List out the connections a node has with other nodes')
  .argument('<alias_or_public_key>', 'Node in the graph to look up')
  .help('--filter variables: AGE/CAPACITY/HOPS/IN_FEE_RATE/OUT_FEE_RATE')
  .help('Example: --filter "age<7*144" for connections in the last week')
  .help(' â†-PPM will represent a source-based inbound discount when present')
  .option('--filter <formula>', 'Filter formula to apply', REPEATABLE)
  .option('--node <node_name>', 'Node to use for lookup')
  .option('--sort <sort_connections_by', 'Sort peers by field')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await lndForNode(logger, options.node);

        return network.getGraphEntry({
          lnd,
          logger,
          filters: flatten([options.filter].filter(n => !!n)),
          fs: {getFile: readFile},
          query: args.aliasOrPublicKey.trim(),
          sort: options.sort,
        },
        responses.returnObject({logger, reject, resolve, table: 'rows'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get inbound liquidity information: available inbound off-chain tokens
  .command('inbound-liquidity', 'Get inbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--max-fee-rate <fee_rate>', 'Maximum fee rate to consider', INT)
  .option('--node <node_name>', 'Node to get inbound liquidity')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <node_key_or_tag>', 'Liquidity with a specific node/tag')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return balances.getLiquidity({
          above: options.above || undefined,
          below: options.below || undefined,
          fs: {getFile: readFile},
          is_top: options.top || undefined,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          max_fee_rate: options.maxFeeRate || undefined,
          request: commands.simpleRequest,
          with: options.with,
        },
        responses.returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Saved nodes
  .command('nodes', 'List and edit saved nodes')
  .help('Locking and unlocking requires existing installation of GPG')
  .argument('[node]', 'Specify a saved node')
  .option('--add', 'Add a new node')
  .option('--lock <id>', 'Encrypt node authentication to GPG key', REPEATABLE)
  .option('--remove', 'Remove saved node')
  .option('--unlock', 'Remove encryption from auth macaroon')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      return nodes.manageSavedNodes({
        logger,
        spawn,
        ask: await commands.interrogate({}),
        fs: {
          writeFile,
          getDirectoryFiles: readdir,
          getFile: readFile,
          getFileStatus: lstat,
          makeDirectory: mkdir,
          removeDirectory: rmdir,
          removeFile: unlink,
        },
        is_registering: options.add || undefined,
        is_removing: options.remove || undefined,
        is_unlocking: options.unlock || undefined,
        lock_credentials_to: flatten([options.lock].filter(n => !!n)),
        node: args.node || undefined,
      },
      responses.returnObject({logger, reject, resolve}));
    });
  })

  // Get outbound liquidity information: available outbound off-chain tokens
  .command('outbound-liquidity', 'Get outbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--node <node_name>', 'Node to get outbound liquidity amount')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <public_key_or_tag>', 'Liquidity with a specific node/tag')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return balances.getLiquidity({
          above: options.above || undefined,
          below: options.below || undefined,
          fs: {getFile: readFile},
          is_outbound: true,
          is_top: options.top || undefined,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          with: options.with,
        },
        responses.returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get a list of channel-connected peers
  .command('peers', 'Get a list of channel-connected peers')
  .help(`Sort options: ${peerSortOptions.join(', ')}`)
  .help('Icons: ðŸ¤¢ often d/c, ðŸ’¸ active HTLC, ðŸ’€ d/c, ðŸŒš private')
  .help('Icons: ðŸ§Š delayed coop close, â³ pending channel, ðŸš« in disabled')
  .help('Icons: ðŸ¦ limited max htlc')
  .help('Filters can take formula expressions to limit results')
  .help('Filter variable AGE: "age > 144 * 7" for peers older than a week')
  .help('Filter variable BLOCKS_SINCE_LAST_CHANNEL: blocks since recent open')
  .help('Filter variable CAPACITY: "capacity > 8*m"')
  .help('Filter variable DISK_USAGE_MB: "disk_usage_mb > 9" for disk estimate')
  .help('Filter variable INBOUND_LIQUIDITY: "inbound_liquidity > 1*m"')
  .help('Filter variable OUTBOUND_LIQUIDITY: "outbound_liquidity > 1*m"')
  .option('--active', 'Only active peer channels')
  .option('--complete', 'Show complete set of records in non table view')
  .option('--fee-days <past_days>', 'Include fees earned over n days', INT)
  .option('--filter <formula>', 'Filter formula to apply', REPEATABLE)
  .option('--idle-days <days>', 'No receives or routes for n days', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get peers for')
  .option('--offline', 'Only offline peer channels')
  .option('--omit <key>', 'Omit peer with public key', REPEATABLE)
  .option('--private', 'Only private channels')
  .option('--public', 'Only peers with public channels')
  .option('--sort <by>', 'Sort results by peer attribute', peerSortOptions)
  .option('--tag <tag_name>', 'Only show peers in a tag', REPEATABLE)
  .action((args, options, logger) => {
    const table = !!options.complete ? undefined : 'rows';

    return new Promise(async (resolve, reject) => {
      try {
        return network.getPeers({
          earnings_days: options.feeDays,
          filters: flatten([options.filter].filter(n => !!n)),
          fs: {getFile: readFile},
          idle_days: options.idleDays || undefined,
          is_active: !!options.active,
          is_monochrome: !!options.noColor,
          is_offline: !!options.offline,
          is_private: !!options.private,
          is_public: !!options.public,
          is_table: !options.complete,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          omit: flatten([options.omit].filter(n => !!n)),
          sort_by: options.sort,
          tags: flatten([options.tag].filter(n => !!n)),
        },
        responses.returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Determine if a payment request is sendable
  .command('probe', 'Check if a payment request is sendable')
  .help('Simulate paying a payment request without actually paying it')
  .argument('<to>', 'Payment request or node public key')
  .argument('[amount]', 'Amount to probe, default: request amount')
  .option('--avoid <avoid>', 'Avoid forwarding via node/chan/tag', REPEATABLE)
  .option('--avoid-high-fee-routes', 'Avoid evaluating too-high fee routes')
  .option('--find-max', 'Find the maximum routeable amount on success route')
  .option('--in <public_key>', 'Route through specific peer of destination')
  .option('--max-fee <max_fee>', 'Max expected fee for route', INT, 1337)
  .option('--max-paths <max>', 'Maximum paths to use for find-max', INT, 1)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use for payment request check')
  .option('--out <public_key>', 'Make first hop through peer', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await lndForNode(logger, options.node);

        const inThrough = await lnSync.findKey({lnd, query: options.in});

        return network.probe({
          lnd,
          logger,
          avoid: flatten([options.avoid].filter(n => !!n)),
          destination: args.to.length === 66 ? args.to : undefined,
          find_max: !!options.findMax ? 16777215 : undefined,
          fs: {getFile: readFile},
          in_through: inThrough.public_key,
          is_strict_max_fee: !!options.avoidHighFeeRoutes,
          max_fee: options.maxFee,
          max_paths: options.maxPaths,
          out: flatten([options.out].filter(n => !!n)),
          request: args.to.length !== 66 ? args.to : undefined,
          tokens: args.amount || undefined,
        },
        responses.returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // See a general report about the node
  .command('report', 'Report about the node')
  .option('--node <node_name>', 'Node to get report for')
  .option('--styled', 'Add unicode styling to report')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return wallets.getReport({
        fs: {getFile: readFile},
        node: options.node,
        request: commands.simpleRequest,
        style: !!options.styled ? 'styled' : undefined,
      },
      responses.returnOutput({logger, reject, resolve}));
    });
  })

  // Adjust the set of tagged nodes
  .command('tags', 'View or adjust the set of tagged nodes')
  .help('Tags can be used in other commands via --tag and --avoid options')
  .argument('[tag]', 'Adjust or view a specific tag')
  .option('--add <public_key', 'Add a public key to a tag', REPEATABLE)
  .option('--avoid', 'Mark to globally avoid all tagged nodes', BOOL, true)
  .option('--icon <icon>', 'Icon to use for the tag')
  .option('--remove <public_key>', 'Remove a public key from a tag', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return await nodes.adjustTags({
          add: flatten([options.add].filter(n => !!n)),
          fs: {writeFile, getFile: readFile, makeDirectory: mkdir},
          icon: options.icon,
          is_avoided: options.avoid,
          remove: flatten([options.remove].filter(n => !!n)),
          tag: !!args.tag ? args.tag.toLowerCase() : undefined,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Link up RocketChat bot
  .command('rocketchat', 'Post updates to a RocketChat bot')
  .help('Connect to a RocketChat bot. Create bot in RocketChat')
  .help('Supported updates: forwards, received payments, etc')
  .help('Multiple nodes are supported by repeating the `--node` flag')
  .help('See README for info on persisting the bot through nohup')
  .help('--use-proxy requires path to JSON file for host/password/port/userId')
  .option('--budget <amount>', 'Spending amount to allow', INT, Number())
  .option('--connect <connect_code>', 'Connection code from /connect')
  .option('--ignore-forwards-below <amount>', 'Ignore forwards of value', INT)
  .option('--ignore-rebalances-below <amt>', 'Ignore rebalances of value', INT)
  .option('--node <node_name>', 'Node to connect to RocketChat', REPEATABLE)
  .option('--reset-api-key', 'Reset the RocketChat API key')
  .option('--use-proxy <path>', 'Proxy agent to connect to RocketChat')
  .option('--use-rounded-units', 'No leading zeros or fractions on amounts')
  .option('--use-small-units', 'Avoid showing leading zeros on amounts')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return await rocketchat.connectToRocketChat({
          logger,
          ask: await commands.interrogate({}),
          fs: {
            writeFile,
            getFile: readFile,
            getFileStatus: statSync,
            is_reset_state: options.resetApiKey || undefined,
            makeDirectory: mkdir,
          },
          id: options.connect,
          is_rounded_units: options.useRoundedUnits || undefined,
          is_small_units: options.useSmallUnits || undefined,
          min_forward_tokens: options.ignoreForwardsBelow || undefined,
          min_rebalance_tokens: options.ignoreRebalancesBelow || undefined,
          nodes: flatten([options.node].filter(n => !!n)),
          payments: {limit: options.budget},
          proxy: options.useProxy || undefined,
          request: commands.fetchRequest({fetch}),
        });
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Manage triggers
  .command('triggers', 'Manage event triggers')
  .option('--node <name>', 'Node to manage triggers on')
  .visible(false)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return triggers.manageTriggers({
          logger,
          ask: await commands.interrogate({}),
          lnd: (await lndForNode(logger, options.node)).lnd,
        },
        responses.returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  })

  // Get utxos
  .command('utxos', 'Get a list of utxos')
  .option('--confirmed', 'Return only confirmed utxos')
  .option('--count', 'Return the count of utxos')
  .option('--count-below <below>', 'Return only count below number', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get utxos for')
  .option('--size', 'UTXOs of size greater than or equal to specified amount')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return chain.getUtxos({
          count_below: options.countBelow,
          is_confirmed: !!options.confirmed,
          is_count: !!options.count,
          lnd: (await lnd.authenticatedLnd({logger, node: options.node})).lnd,
          min_tokens: options.size || undefined,
          node: options.node,
        },
        responses.returnObject({logger, reject, resolve}));
      } catch (err) {
        return logger.error({err}) && reject();
      }
    });
  });

prog.parse(process.argv);
